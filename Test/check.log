test.c: In function ‚Äòfoo3‚Äô:
test.c:51:5: warning: assignment makes integer from pointer without a cast [-Wint-conversion]
  *z = malloc(1);
     ^
test.c: In function ‚Äòfoo4‚Äô:
test.c:95:5: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]
  p2 = &b;
     ^
test.c: In function ‚Äòchild‚Äô:
test.c:158:7: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
  data = 10;
       ^
test.c: In function ‚Äòchild3‚Äô:
test.c:184:15: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  int *pData = &data;
               ^
test.c:197:16: warning: format ‚Äò%d‚Äô expects argument of type ‚Äòint‚Äô, but argument 2 has type ‚Äòint *‚Äô [-Wformat=]
  printf("asdda%d\n" ,pData);
               ~^
               %ls
test.c: In function ‚Äòchild2‚Äô:
test.c:210:15: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  int *pData = &data;
               ^
test.c: In function ‚Äòmain‚Äô:
test.c:299:37: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
  pthread_create(&t, &attr2, child2, (void *)input2);
                                     ^
=======ipa_pta=========
start PointerConstraint
pointer ftable is 1 
pointer ptable is 1 
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
=======print_function_var 1656588976   1========
=======print_function_var 1638045088   6========
=======print_function_var 1638060608   1========
=======print_function_var 1638060464   2========
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
=======================================================
=======node_fun: =========
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 2 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:foo5========= [0m
[40;46m =======add node_fun stack:foo5========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path foo5  function_call count: 0 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre_check_funciton:foo5========= [0m
[40;42m =======start_check_funciton:foo5========= [0m
[40;33m =======POP node_fun stack:foo5========= [0m
[40;42m =======pre add _ fucntion:child========= [0m
[40;46m =======add node_fun stack:child========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path child  function_call count: 2 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:boo========= [0m
[40;46m =======add node_fun stack:boo========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path boo  function_call count: 1 level :2========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;46m =======add node_fun stack:test22========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path test22  function_call count: 1 level :3========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;41m =======recursive_fun:test22========= [0m
[40;42m =======pre_check_funciton:test22========= [0m
[40;42m =======start_check_funciton:test22========= [0m
 <function_decl 0x7f8861a01e00 test22
    type <function_type 0x7f8861a00930
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa78 value <pointer_type 0x7f8861e7ca80>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d2a0>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 251 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10780>
    result <result_decl 0x7f8861e6c4b0 D.4063 type <void_type 0x7f8861e75f18 void>
        ignored VOID file test.c line 251 col 6
        align 8 context <function_decl 0x7f8861a01e00 test22>>
    arguments <parm_decl 0x7f8861a12880 k
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        unsigned DI file test.c line 251 col 18 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01e00 test22> arg-type <pointer_type 0x7f8861e7ca80>>
    struct-function 0x7f8861a18420>

======================================================================
 <ssa_name 0x7f8861a21e58
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1dea0 w>
    def_stmt w_10 = malloc (5);
    version 10
    ptr-info 0x7f8861a35150>
w_10 = malloc (5);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
free (w_10);
In function ‚Äòmain‚Äô:
test.c:260:2: warning: use location
  free(w);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (w_10);
test.c:260:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;32m   Maybe you don't have a memory leak.... more checks  [0m

======================================================================

 <function_decl 0x7f8861a01e00 test22
    type <function_type 0x7f8861a00930
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa78 value <pointer_type 0x7f8861e7ca80>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d2a0>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 251 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10780>
    result <result_decl 0x7f8861e6c4b0 D.4063 type <void_type 0x7f8861e75f18 void>
        ignored VOID file test.c line 251 col 6
        align 8 context <function_decl 0x7f8861a01e00 test22>>
    arguments <parm_decl 0x7f8861a12880 k
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        unsigned DI file test.c line 251 col 18 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01e00 test22> arg-type <pointer_type 0x7f8861e7ca80>>
    struct-function 0x7f8861a18420>

======================================================================
 <ssa_name 0x7f8861a21e10
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <parm_decl 0x7f8861a12880 k>
    def_stmt GIMPLE_NOP
    version 2
    ptr-info 0x7f8861a35138>
this other function ------free-----
 
 Start check Pointer Collect  

======================================================================
test22 (k_2(D));
test.c:261:2: warning: use location
  test22(k);
  ^
this stmt is child function---test22-----

 ================== trace ================== 
trace fucntion name:test22 
[40;44m =======trace_function_path test22  function_call count: 1 level :0========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_19 = VDEF <.MEM_18>
free (w_10);
test.c:260:2: warning: use location
  free(w);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;46m =======add node_fun stack:test22========= [0m
[40;44m =======trace_function_path test22  function_call count: 1 level :1========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_19 = VDEF <.MEM_18>
free (w_10);
test.c:260:2: warning: use location
  free(w);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;41m =======recursive_fun:test22========= [0m

 ================== trace ================== 
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (k_2(D));
test.c:258:2: warning: use location
[40;32m    HAS FREE STMT count:15 name:free [0m

 ================== find ================== 
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (k_2(D));
test.c:257:2: warning: use location
[40;32m    HAS FREE STMT count:16 name:free [0m

 ================== find ================== 
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (k_2(D));
test.c:256:2: warning: use location
[40;32m    HAS FREE STMT count:17 name:free [0m

 ================== find ================== 
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (k_2(D));
test.c:255:2: warning: use location
[40;32m    HAS FREE STMT count:18 name:free [0m

 ================== find ================== 
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (k_2(D));
test.c:254:2: warning: use location
[40;32m    HAS FREE STMT count:19 name:free [0m

 ================== find ================== 
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (k_2(D));
test.c:253:2: warning: use location
[40;32m    HAS FREE STMT count:20 name:free [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_20 = VDEF <.MEM_19>
test22 (k_2(D));
test.c:261:2: warning: use location
  test22(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_20 = VDEF <.MEM_19>
test22 (k_2(D));
test.c:261:2: warning: use location
  test22(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_20 = VDEF <.MEM_19>
test22 (k_2(D));
test.c:261:2: warning: use location
  test22(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_20 = VDEF <.MEM_19>
test22 (k_2(D));
test.c:261:2: warning: use location
  test22(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_20 = VDEF <.MEM_19>
test22 (k_2(D));
test.c:261:2: warning: use location
  test22(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_20 = VDEF <.MEM_19>
test22 (k_2(D));
test.c:261:2: warning: use location
  test22(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: Use after free error!: free location
  free(k);
  ^
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m  	possible double free :20 [0m

======================================================================
[40;33m =======POP node_fun stack:test22========= [0m
[40;42m =======pre_check_funciton:boo========= [0m
[40;42m =======thread job funciton:boo========= [0m
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_20 = VDEF <.MEM_19>
pthread_mutex_lock (&mLock);
test.c:152:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_21 = VDEF <.MEM_20>
pthread_mutex_lock (&mLock);
test.c:153:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_36 = VDEF <.MEM_35>
pthread_mutex_unlock (&mLock);
test.c:169:2: warning: use location
  pthread_mutex_unlock(&mLock);
  ^
[40;42m =======thread job funciton lock count :3========= [0m
[40;42m =======start_check_funciton:boo========= [0m
 <function_decl 0x7f8861a01f00 boo
    type <function_type 0x7f8861a00930
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa78 value <pointer_type 0x7f8861e7ca80>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d2a0>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 236 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10660>
    result <result_decl 0x7f8861e6c438 D.4060 type <void_type 0x7f8861e75f18 void>
        ignored VOID file test.c line 236 col 6
        align 8 context <function_decl 0x7f8861a01f00 boo>>
    arguments <parm_decl 0x7f8861a12800 b
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        unsigned DI file test.c line 236 col 15 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01f00 boo> arg-type <pointer_type 0x7f8861e7ca80>>
    struct-function 0x7f8861a18370>

======================================================================
 <ssa_name 0x7f8861a21bd0
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <parm_decl 0x7f8861a12800 b>
    def_stmt GIMPLE_NOP
    version 2
    ptr-info 0x7f8861a35120>
this other function ------ê…√UHâÂHÉÏHâ}¯HâuHãMHãE¯∫-----
 
 Start check Pointer Collect  

======================================================================
test22 (b_2(D));
test.c:240:2: warning: use location
  test22(b);
  ^
this stmt is child function---test22-----

 ================== trace ================== 
trace fucntion name:test22 
[40;44m =======trace_function_path test22  function_call count: 1 level :0========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_19 = VDEF <.MEM_18>
free (w_10);
test.c:260:2: warning: use location
  free(w);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;46m =======add node_fun stack:test22========= [0m
[40;44m =======trace_function_path test22  function_call count: 1 level :1========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_19 = VDEF <.MEM_18>
free (w_10);
test.c:260:2: warning: use location
  free(w);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;41m =======recursive_fun:test22========= [0m

 ================== trace ================== 
free (b_2(D));
test.c:239:2: warning: use location
  free(b);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (b_2(D));
test.c:239:2: warning: use location
[40;32m    HAS FREE STMT count:15 name:free [0m

 ================== find ================== 
free (b_2(D));
test.c:238:2: warning: use location
  free(b);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (b_2(D));
test.c:238:2: warning: use location
[40;32m    HAS FREE STMT count:16 name:free [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 
# .MEM_9 = VDEF <.MEM_8>
free (b_2(D));
test.c:239:2: warning: Use after free error!: free location
  free(b);
  ^
# .MEM_10 = VDEF <.MEM_9>
test22 (b_2(D));
test.c:240:2: warning: use location
  test22(b);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_8 = VDEF <.MEM_7(D)>
free (b_2(D));
test.c:238:2: warning: Use after free error!: free location
  free(b);
  ^
# .MEM_10 = VDEF <.MEM_9>
test22 (b_2(D));
test.c:240:2: warning: use location
  test22(b);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_8 = VDEF <.MEM_7(D)>
free (b_2(D));
test.c:238:2: warning: Use after free error!: free location
  free(b);
  ^
# .MEM_9 = VDEF <.MEM_8>
free (b_2(D));
test.c:239:2: warning: use location
  free(b);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m  	possible double free :16 [0m

======================================================================
[40;42m =======pre_check_funciton:boo========= [0m
[40;42m =======start_check_funciton:boo========= [0m
 <function_decl 0x7f8861a01f00 boo
    type <function_type 0x7f8861a00930
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa78 value <pointer_type 0x7f8861e7ca80>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d2a0>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 236 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10660>
    result <result_decl 0x7f8861e6c438 D.4060 type <void_type 0x7f8861e75f18 void>
        ignored VOID file test.c line 236 col 6
        align 8 context <function_decl 0x7f8861a01f00 boo>>
    arguments <parm_decl 0x7f8861a12800 b
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        unsigned DI file test.c line 236 col 15 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01f00 boo> arg-type <pointer_type 0x7f8861e7ca80>>
    struct-function 0x7f8861a18370>

======================================================================
 <ssa_name 0x7f8861a21bd0
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <parm_decl 0x7f8861a12800 b>
    def_stmt GIMPLE_NOP
    version 2
    ptr-info 0x7f8861a35120>
this other function ------free-----
 
 Start check Pointer Collect  

======================================================================
test22 (b_2(D));
test.c:240:2: warning: use location
  test22(b);
  ^
this stmt is child function---test22-----

 ================== trace ================== 
trace fucntion name:test22 
[40;44m =======trace_function_path test22  function_call count: 1 level :0========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_19 = VDEF <.MEM_18>
free (w_10);
test.c:260:2: warning: use location
  free(w);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;46m =======add node_fun stack:test22========= [0m
[40;44m =======trace_function_path test22  function_call count: 1 level :1========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_19 = VDEF <.MEM_18>
free (w_10);
test.c:260:2: warning: use location
  free(w);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;41m =======recursive_fun:test22========= [0m

 ================== trace ================== 
free (b_2(D));
test.c:239:2: warning: use location
  free(b);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (b_2(D));
test.c:239:2: warning: use location
[40;32m    HAS FREE STMT count:15 name:free [0m

 ================== find ================== 
free (b_2(D));
test.c:238:2: warning: use location
  free(b);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (b_2(D));
test.c:238:2: warning: use location
[40;32m    HAS FREE STMT count:16 name:free [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 
# .MEM_9 = VDEF <.MEM_8>
free (b_2(D));
test.c:239:2: warning: Use after free error!: free location
  free(b);
  ^
# .MEM_10 = VDEF <.MEM_9>
test22 (b_2(D));
test.c:240:2: warning: use location
  test22(b);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_8 = VDEF <.MEM_7(D)>
free (b_2(D));
test.c:238:2: warning: Use after free error!: free location
  free(b);
  ^
# .MEM_10 = VDEF <.MEM_9>
test22 (b_2(D));
test.c:240:2: warning: use location
  test22(b);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
# .MEM_8 = VDEF <.MEM_7(D)>
free (b_2(D));
test.c:238:2: warning: Use after free error!: free location
  free(b);
  ^
# .MEM_9 = VDEF <.MEM_8>
free (b_2(D));
test.c:239:2: warning: use location
  free(b);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m  	possible double free :16 [0m

======================================================================
[40;33m =======POP node_fun stack:boo========= [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;46m =======add node_fun stack:foo========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre_check_funciton:child========= [0m
[40;42m =======start_check_funciton:child========= [0m
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a2d0
    type <pointer_type 0x7f8861a0ce70
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        public unsigned DI size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f8861a29630 ppData>
    def_stmt ppData_13 = malloc (10);
    version 13
    ptr-info 0x7f8861a351f8>
ppData_13 = malloc (10);
this Reserved word function ------malloc-----

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m
test.c:154:8: warning: use location
  int **ppData = malloc(10);
        ^

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a120
    type <pointer_type 0x7f8861e7c0a8
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a001f8>>
   
    def_stmt _2 = malloc (20);
    version 2
    ptr-info 0x7f8861a35168>
_2 = malloc (20);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
pData = _2;
test.c:155:7: warning: use location
  int *pData = malloc(20);
       ^
_4 = MEM[(int * *)&pData + 8B];
test.c:162:9: warning: use location
  *ppData[1] = 10;
         ^
*_4 = 10;
test.c:162:13: warning: use location
  *ppData[1] = 10;
             ^
_5 = MEM[(int * *)&pData + 16B];
test.c:163:9: warning: use location
  *ppData[2] = 10;
         ^
*_5 = 10;
test.c:163:13: warning: use location
  *ppData[2] = 10;
             ^
free (&pData);
test.c:168:2: warning: use location
  free(ppData);
  ^
this stmt is child function---free-----

 ================== trace ================== 
trace fucntion name:free 

 ================== trace ================== 
free (&pData);
test.c:170:2: warning: use location
  free(ppData);
  ^
this stmt is child function---free-----

 ================== trace ================== 
trace fucntion name:free 

 ================== trace ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a318
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a29510 a>
    def_stmt a_17 = foo (1);
    version 17
    ptr-info 0x7f8861a35210>
this other function ------foo-----
 
 Start check Pointer Collect  

======================================================================

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <integer_cst 0x7f8861a03e40 type <pointer_type 0x7f8861e7c0a8> constant 10>
 <integer_cst 0x7f8861a03e40 type <pointer_type 0x7f8861e7c0a8> constant 10>
this other function ------foo-----

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m
test.c:167:2: warning: use location
  boo(data);
  ^

======================================================================
[40;44m =======print_function_path foo  function_call count: 1 level :2========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:foo2========= [0m
[40;46m =======add node_fun stack:foo2========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m
 <function_decl 0x7f8861a06100 foo
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 105 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10420>
    result <result_decl 0x7f8861e6c348 D.4053 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 105 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06100 foo>>
    arguments <parm_decl 0x7f8861a12700 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 105 col 14 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06100 foo> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18210>

======================================================================
 <ssa_name 0x7f8861a21750
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d870 p2>
    def_stmt p2_3 = malloc (1);
    version 3
    ptr-info 0x7f8861a350d8>
p2_3 = malloc (1);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
*p2_3 = 1;
test.c:109:8: warning: use location
  p2[0] = 1;
        ^

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
 <function_decl 0x7f8861a06100 foo
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 105 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10420>
    result <result_decl 0x7f8861e6c348 D.4053 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 105 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06100 foo>>
    arguments <parm_decl 0x7f8861a12700 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 105 col 14 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06100 foo> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18210>

======================================================================
 <ssa_name 0x7f8861a217e0
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
   
    def_stmt _7 = foo2 (z_5(D));
    version 7
    ptr-info 0x7f8861a350f0>
this other function ------foo2-----
 
 Start check Pointer Collect  

======================================================================
return _7;
test.c:124:9: warning: use location
  return foo2(z);
         ^

 ================== warring ================== 

[40;35m    function return value related stmt [0m
[40;35m    this stmt possible is heap-object „ÄÇ [0m

 ================== warring ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
[40;44m =======print_function_path foo2  function_call count: 1 level :3========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:foo3========= [0m
[40;46m =======add node_fun stack:foo3========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path foo3  function_call count: 0 level :4========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre_check_funciton:foo3========= [0m
[40;42m =======start_check_funciton:foo3========= [0m
 <function_decl 0x7f8861a06300 foo3
    type <function_type 0x7f8861a00930
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa78 value <pointer_type 0x7f8861e7ca80>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d2a0>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 43 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10360>
    result <result_decl 0x7f8861e6c258 D.4043 type <void_type 0x7f8861e75f18 void>
        ignored VOID file test.c line 43 col 6
        align 8 context <function_decl 0x7f8861a06300 foo3>>
    arguments <parm_decl 0x7f8861a12580 z
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        unsigned DI file test.c line 43 col 16 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06300 foo3> arg-type <pointer_type 0x7f8861e7ca80>>
    struct-function 0x7f8861a180b0>

======================================================================
 <ssa_name 0x7f8861e69cf0
    type <pointer_type 0x7f8861e7c0a8
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a001f8>>
   
    def_stmt _1 = malloc (1);
    version 1
    ptr-info 0x7f8861a03fd8>
_1 = malloc (1);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_2 = (long int) _1;
test.c:51:5: warning: use location
  *z = malloc(1);
     ^
_3 = (int) _2;
test.c:51:5: warning: use location
*z_6(D) = _3;
test.c:51:5: warning: use location

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:foo3========= [0m
[40;42m =======pre_check_funciton:foo2========= [0m
[40;42m =======thread job funciton:foo2========= [0m
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_41 = VDEF <.MEM_40>
pthread_mutex_lock (&mLock);
test.c:64:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_42 = VDEF <.MEM_41>
pthread_mutex_lock (&mLock2);
test.c:65:2: warning: use location
  pthread_mutex_lock(&mLock2);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_43 = VDEF <.MEM_42>
pthread_mutex_lock (&mLock3);
test.c:66:2: warning: use location
  pthread_mutex_lock(&mLock3);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_20 = VDEF <.MEM_19>
pthread_mutex_lock (&mLock);
test.c:152:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_21 = VDEF <.MEM_20>
pthread_mutex_lock (&mLock);
test.c:153:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_36 = VDEF <.MEM_35>
pthread_mutex_unlock (&mLock);
test.c:169:2: warning: use location
  pthread_mutex_unlock(&mLock);
  ^
[40;42m =======thread job funciton lock count :6========= [0m
[40;42m =======start_check_funciton:foo2========= [0m
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861a21090
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d1b0 a2>
    def_stmt a2_12 = malloc (_1);
    version 12
    ptr-info 0x7f8861a35060>
a2_12 = malloc (_1);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
*a2_12 = 10;
test.c:61:8: warning: use location
  a2[0] = 10;
        ^
 
 LOCAL VARIBALE  
# .MEM_39 = VDEF <.MEM_38>
*a2_12 = 10;
test.c:61:8: warning: use location
 
 LOCAL VARIBALE  

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861a210d8
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d120 p3>
    def_stmt p3_14 = malloc (_2);
    version 14
    ptr-info 0x7f8861a35078>
p3_14 = malloc (_2);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_7 = PHI <p3_14(3), p4_16(4)>
lto1: warning: use location
this stmt have mutiple branch ---malloc-----
_31 = p3_14;
test.c:73:10: warning: use location
   return p3;
          ^
 
 LOCAL VARIBALE  
_31 = p3_14;
test.c:73:10: warning: use location
 
 LOCAL VARIBALE  
free (p3_14);
test.c:72:3: warning: use location
   free(p3);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (p3_14);
test.c:72:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
*p3_14 = 10;
test.c:71:9: warning: use location
   p3[0] = 10;
         ^
 
 LOCAL VARIBALE  
# .MEM_47 = VDEF <.MEM_44>
*p3_14 = 10;
test.c:71:9: warning: use location
 
 LOCAL VARIBALE  
foo3 (p3_14);
test.c:67:2: warning: use location
  foo3(p3);
  ^
this stmt is child function---foo3-----

 ================== trace ================== 
trace fucntion name:foo3 
[40;44m =======trace_function_path foo3  function_call count: 0 level :0========  [0m
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_2 = (long int) _1;
In function ‚Äòfoo3‚Äô:
test.c:51:5: warning: use location
  *z = malloc(1);
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_3 = (int) _2;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_9 = VDEF <.MEM_8>
*z_6(D) = _3;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo3  function_call count: 0 level :1========  [0m

 ================== trace ================== 
return _7;
In function ‚Äòmain‚Äô:
lto1: warning: use location

 ================== Start Use after free Check ================== 
# .MEM_48 = VDEF <.MEM_47>
free (p3_14);
test.c:72:3: warning: Use after free error!: free location
   free(p3);
   ^
_31 = p3_14;
test.c:73:10: warning: use location
   return p3;
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m 	this fucntion return possible is heap-object [0m

======================================================================
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861a21120
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d090 p4>
    def_stmt p4_16 = malloc (_3);
    version 16
    ptr-info 0x7f8861a35090>
p4_16 = malloc (_3);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_7 = PHI <p3_14(3), p4_16(4)>
lto1: warning: use location
this stmt have mutiple branch ---malloc-----
_28 = p4_16;
test.c:79:10: warning: use location
   return p4;
          ^
 
 LOCAL VARIBALE  
_28 = p4_16;
test.c:79:10: warning: use location
 
 LOCAL VARIBALE  
free (p4_16);
test.c:78:3: warning: use location
   free(p4);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (p4_16);
test.c:78:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
*p4_16 = 10;
test.c:77:9: warning: use location
   p4[0] = 10;
         ^
 
 LOCAL VARIBALE  
# .MEM_45 = VDEF <.MEM_44>
*p4_16 = 10;
test.c:77:9: warning: use location
 
 LOCAL VARIBALE  
return _7;
lto1: warning: use location

 ================== Start Use after free Check ================== 
# .MEM_46 = VDEF <.MEM_45>
free (p4_16);
test.c:78:3: warning: Use after free error!: free location
   free(p4);
   ^
_28 = p4_16;
test.c:79:10: warning: use location
   return p4;
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m 	this fucntion return possible is heap-object [0m

======================================================================
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861e698b8
    type <pointer_type 0x7f8861e7c0a8
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a001f8>>
   
    def_stmt _5 = malloc (_4);
    version 5
    ptr-info 0x7f8861a35018>
_5 = malloc (_4);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
p99 = _5;
test.c:59:6: warning: use location
  p99 = malloc(z);
      ^

 ================== warring  ================== 
[40;35m warring thread fucntion detction is on [0m
[40;35m Detect GLOBAL VARIBALE [0m
# .MEM_38 = VDEF <.MEM_37>
p99 = _5;
test.c:59:6: warning: use location
[40;35m thread job function [0m
[40;35m this stmt possible have Race Condition „ÄÇ [0m

 ================== warring  ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;42m =======pre_check_funciton:foo2========= [0m
[40;42m =======start_check_funciton:foo2========= [0m
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861a21090
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d1b0 a2>
    def_stmt a2_12 = malloc (_1);
    version 12
    ptr-info 0x7f8861a35060>
a2_12 = malloc (_1);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
*a2_12 = 10;
test.c:61:8: warning: use location
  a2[0] = 10;
        ^

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861a210d8
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d120 p3>
    def_stmt p3_14 = malloc (_2);
    version 14
    ptr-info 0x7f8861a35078>
p3_14 = malloc (_2);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_7 = PHI <p3_14(3), p4_16(4)>
lto1: warning: use location
this stmt have mutiple branch ---malloc-----
_31 = p3_14;
test.c:73:10: warning: use location
   return p3;
          ^
free (p3_14);
test.c:72:3: warning: use location
   free(p3);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (p3_14);
test.c:72:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
*p3_14 = 10;
test.c:71:9: warning: use location
   p3[0] = 10;
         ^
foo3 (p3_14);
test.c:67:2: warning: use location
  foo3(p3);
  ^
this stmt is child function---foo3-----

 ================== trace ================== 
trace fucntion name:foo3 
[40;44m =======trace_function_path foo3  function_call count: 0 level :0========  [0m
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_2 = (long int) _1;
In function ‚Äòfoo3‚Äô:
test.c:51:5: warning: use location
  *z = malloc(1);
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_3 = (int) _2;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_9 = VDEF <.MEM_8>
*z_6(D) = _3;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo3  function_call count: 0 level :1========  [0m

 ================== trace ================== 
return _7;
In function ‚Äòmain‚Äô:
lto1: warning: use location

 ================== Start Use after free Check ================== 
# .MEM_48 = VDEF <.MEM_47>
free (p3_14);
test.c:72:3: warning: Use after free error!: free location
   free(p3);
   ^
_31 = p3_14;
test.c:73:10: warning: use location
   return p3;
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m 	this fucntion return possible is heap-object [0m

======================================================================
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861a21120
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d090 p4>
    def_stmt p4_16 = malloc (_3);
    version 16
    ptr-info 0x7f8861a35090>
p4_16 = malloc (_3);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_7 = PHI <p3_14(3), p4_16(4)>
lto1: warning: use location
this stmt have mutiple branch ---malloc-----
_28 = p4_16;
test.c:79:10: warning: use location
   return p4;
          ^
free (p4_16);
test.c:78:3: warning: use location
   free(p4);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (p4_16);
test.c:78:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
*p4_16 = 10;
test.c:77:9: warning: use location
   p4[0] = 10;
         ^
return _7;
lto1: warning: use location

 ================== Start Use after free Check ================== 
# .MEM_46 = VDEF <.MEM_45>
free (p4_16);
test.c:78:3: warning: Use after free error!: free location
   free(p4);
   ^
_28 = p4_16;
test.c:79:10: warning: use location
   return p4;
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m 	this fucntion return possible is heap-object [0m

======================================================================
 <function_decl 0x7f8861a06200 foo2
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 53 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a103c0>
    result <result_decl 0x7f8861e6c2d0 D.4046 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 53 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06200 foo2>>
    arguments <parm_decl 0x7f8861a12600 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 53 col 15 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06200 foo2> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18160>

======================================================================
 <ssa_name 0x7f8861e698b8
    type <pointer_type 0x7f8861e7c0a8
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a001f8>>
   
    def_stmt _5 = malloc (_4);
    version 5
    ptr-info 0x7f8861a35018>
_5 = malloc (_4);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
p99 = _5;
test.c:59:6: warning: use location
  p99 = malloc(z);
      ^

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:foo2========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======thread job funciton:foo========= [0m
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_20 = VDEF <.MEM_19>
pthread_mutex_lock (&mLock);
test.c:152:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_21 = VDEF <.MEM_20>
pthread_mutex_lock (&mLock);
test.c:153:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_36 = VDEF <.MEM_35>
pthread_mutex_unlock (&mLock);
test.c:169:2: warning: use location
  pthread_mutex_unlock(&mLock);
  ^
[40;42m =======thread job funciton lock count :3========= [0m
[40;42m =======start_check_funciton:foo========= [0m
 <function_decl 0x7f8861a06100 foo
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 105 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10420>
    result <result_decl 0x7f8861e6c348 D.4053 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 105 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06100 foo>>
    arguments <parm_decl 0x7f8861a12700 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 105 col 14 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06100 foo> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18210>

======================================================================
 <ssa_name 0x7f8861a21750
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d870 p2>
    def_stmt p2_3 = malloc (1);
    version 3
    ptr-info 0x7f8861a350d8>
p2_3 = malloc (1);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
*p2_3 = 1;
test.c:109:8: warning: use location
  p2[0] = 1;
        ^
 
 LOCAL VARIBALE  
# .MEM_10 = VDEF <.MEM_9>
*p2_3 = 1;
test.c:109:8: warning: use location
 
 LOCAL VARIBALE  

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
 <function_decl 0x7f8861a06100 foo
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 105 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10420>
    result <result_decl 0x7f8861e6c348 D.4053 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 105 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06100 foo>>
    arguments <parm_decl 0x7f8861a12700 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 105 col 14 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06100 foo> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18210>

======================================================================
 <ssa_name 0x7f8861a217e0
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
   
    def_stmt _7 = foo2 (z_5(D));
    version 7
    ptr-info 0x7f8861a350f0>
this other function ------foo2-----
 
 Start check Pointer Collect  

======================================================================
return _7;
test.c:124:9: warning: use location
  return foo2(z);
         ^

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m
 <function_decl 0x7f8861a06100 foo
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 105 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10420>
    result <result_decl 0x7f8861e6c348 D.4053 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 105 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06100 foo>>
    arguments <parm_decl 0x7f8861a12700 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 105 col 14 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06100 foo> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18210>

======================================================================
 <ssa_name 0x7f8861a21750
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a1d870 p2>
    def_stmt p2_3 = malloc (1);
    version 3
    ptr-info 0x7f8861a350d8>
p2_3 = malloc (1);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
*p2_3 = 1;
test.c:109:8: warning: use location
  p2[0] = 1;
        ^

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
 <function_decl 0x7f8861a06100 foo
    type <function_type 0x7f8861a009d8
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffb18 value <integer_type 0x7f8861e755e8 int>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a0d1f8>>
    addressable nothrow static function-specific-target function-specific-opt QI file test.c line 105 col 6 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a10420>
    result <result_decl 0x7f8861e6c348 D.4053 type <pointer_type 0x7f8861e7ca80>
        unsigned ignored DI file test.c line 105 col 6 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a06100 foo>>
    arguments <parm_decl 0x7f8861a12700 z
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        SI file test.c line 105 col 14 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a06100 foo> arg-type <integer_type 0x7f8861e755e8 int>>
    struct-function 0x7f8861a18210>

======================================================================
 <ssa_name 0x7f8861a217e0
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
   
    def_stmt _7 = foo2 (z_5(D));
    version 7
    ptr-info 0x7f8861a350f0>
this other function ------foo2-----
 
 Start check Pointer Collect  

======================================================================
return _7;
test.c:124:9: warning: use location
  return foo2(z);
         ^

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
[40;33m =======POP node_fun stack:foo========= [0m
[40;42m =======pre_check_funciton:child========= [0m
[40;42m =======thread job funciton:child========= [0m
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_20 = VDEF <.MEM_19>
pthread_mutex_lock (&mLock);
test.c:152:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_21 = VDEF <.MEM_20>
pthread_mutex_lock (&mLock);
test.c:153:2: warning: use location
  pthread_mutex_lock(&mLock);
  ^
[40;44m ======= print pthread lock stmt 666 ========  [0m
# .MEM_36 = VDEF <.MEM_35>
pthread_mutex_unlock (&mLock);
test.c:169:2: warning: use location
  pthread_mutex_unlock(&mLock);
  ^
[40;42m =======thread job funciton lock count :3========= [0m
[40;42m =======start_check_funciton:child========= [0m
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a2d0
    type <pointer_type 0x7f8861a0ce70
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        public unsigned DI size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f8861a29630 ppData>
    def_stmt ppData_13 = malloc (10);
    version 13
    ptr-info 0x7f8861a351f8>
ppData_13 = malloc (10);
this Reserved word function ------malloc-----

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m
test.c:154:8: warning: use location
  int **ppData = malloc(10);
        ^

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a120
    type <pointer_type 0x7f8861e7c0a8
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a001f8>>
   
    def_stmt _2 = malloc (20);
    version 2
    ptr-info 0x7f8861a35168>
_2 = malloc (20);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
pData = _2;
test.c:155:7: warning: use location
  int *pData = malloc(20);
       ^
 
 LOCAL VARIBALE  
# .MEM_24 = VDEF <.MEM_23>
pData = _2;
test.c:155:7: warning: use location
 
 LOCAL VARIBALE  
_4 = MEM[(int * *)&pData + 8B];
test.c:162:9: warning: use location
  *ppData[1] = 10;
         ^
 
 LOCAL VARIBALE  
# VUSE <.MEM_28>
_4 = MEM[(int * *)&pData + 8B];
test.c:162:9: warning: use location
 
 LOCAL VARIBALE  
*_4 = 10;
test.c:162:13: warning: use location
  *ppData[1] = 10;
             ^
 
 LOCAL VARIBALE  
# .MEM_29 = VDEF <.MEM_28>
*_4 = 10;
test.c:162:13: warning: use location
 
 LOCAL VARIBALE  
_5 = MEM[(int * *)&pData + 16B];
test.c:163:9: warning: use location
  *ppData[2] = 10;
         ^
 
 LOCAL VARIBALE  
# VUSE <.MEM_29>
_5 = MEM[(int * *)&pData + 16B];
test.c:163:9: warning: use location
 
 LOCAL VARIBALE  
*_5 = 10;
test.c:163:13: warning: use location
  *ppData[2] = 10;
             ^
 
 LOCAL VARIBALE  
# .MEM_30 = VDEF <.MEM_29>
*_5 = 10;
test.c:163:13: warning: use location
 
 LOCAL VARIBALE  
free (&pData);
test.c:168:2: warning: use location
  free(ppData);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (&pData);
test.c:168:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
free (&pData);
test.c:170:2: warning: use location
  free(ppData);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (&pData);
test.c:170:2: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 
# .MEM_35 = VDEF <.MEM_34>
free (&pData);
test.c:168:2: warning: Use after free error!: free location
  free(ppData);
  ^
# .MEM_37 = VDEF <.MEM_36>
free (&pData);
test.c:170:2: warning: use location
  free(ppData);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m  	possible double free :2 [0m

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a318
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a29510 a>
    def_stmt a_17 = foo (1);
    version 17
    ptr-info 0x7f8861a35210>
this other function ------foo-----
 
 Start check Pointer Collect  

======================================================================

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <integer_cst 0x7f8861a03e40 type <pointer_type 0x7f8861e7c0a8> constant 10>
 <integer_cst 0x7f8861a03e40 type <pointer_type 0x7f8861e7c0a8> constant 10>
this other function ------foo-----

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m
test.c:167:2: warning: use location
  boo(data);
  ^

======================================================================
[40;42m =======pre_check_funciton:child========= [0m
[40;42m =======start_check_funciton:child========= [0m
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a2d0
    type <pointer_type 0x7f8861a0ce70
        type <pointer_type 0x7f8861e7ca80 type <integer_type 0x7f8861e755e8 int>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a0ce70>>
        public unsigned DI size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f8861a29630 ppData>
    def_stmt ppData_13 = malloc (10);
    version 13
    ptr-info 0x7f8861a351f8>
ppData_13 = malloc (10);
this Reserved word function ------malloc-----

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m
test.c:154:8: warning: use location
  int **ppData = malloc(10);
        ^

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a120
    type <pointer_type 0x7f8861e7c0a8
        type <void_type 0x7f8861e75f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861e7c0a8>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a001f8>>
   
    def_stmt _2 = malloc (20);
    version 2
    ptr-info 0x7f8861a35168>
_2 = malloc (20);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
pData = _2;
test.c:155:7: warning: use location
  int *pData = malloc(20);
       ^
_4 = MEM[(int * *)&pData + 8B];
test.c:162:9: warning: use location
  *ppData[1] = 10;
         ^
*_4 = 10;
test.c:162:13: warning: use location
  *ppData[1] = 10;
             ^
_5 = MEM[(int * *)&pData + 16B];
test.c:163:9: warning: use location
  *ppData[2] = 10;
         ^
*_5 = 10;
test.c:163:13: warning: use location
  *ppData[2] = 10;
             ^
free (&pData);
test.c:168:2: warning: use location
  free(ppData);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (&pData);
test.c:168:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
free (&pData);
test.c:170:2: warning: use location
  free(ppData);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (&pData);
test.c:170:2: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 
# .MEM_35 = VDEF <.MEM_34>
free (&pData);
test.c:168:2: warning: Use after free error!: free location
  free(ppData);
  ^
# .MEM_37 = VDEF <.MEM_36>
free (&pData);
test.c:170:2: warning: use location
  free(ppData);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

======================================================================
[40;31m  	possible double free :2 [0m

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <ssa_name 0x7f8861a2a318
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a29510 a>
    def_stmt a_17 = foo (1);
    version 17
    ptr-info 0x7f8861a35210>
this other function ------foo-----
 
 Start check Pointer Collect  

======================================================================

 ================== Start Use after free Check ================== 

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================
 <function_decl 0x7f8861a01d00 child
    type <function_type 0x7f8861a00888
        type <pointer_type 0x7f8861e7c0a8 type <void_type 0x7f8861e75f18 void>
            public unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f8861a001f8>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality
        arg-types <tree_list 0x7f88619ffa00 value <pointer_type 0x7f8861e7c0a8>
            chain <tree_list 0x7f8861e74ac8 value <void_type 0x7f8861e75f18 void>>>
        pointer_to_this <pointer_type 0x7f8861a00498>>
    addressable volatile nothrow static function-specific-target function-specific-opt QI file test.c line 126 col 7 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> attributes <tree_list 0x7f88619ff9d8> initial <block 0x7f8861a107e0>
    result <result_decl 0x7f8861e6c528 D.4067 type <pointer_type 0x7f8861e7c0a8>
        unsigned ignored DI file test.c line 126 col 7 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child>>
    arguments <parm_decl 0x7f8861a12900 data type <pointer_type 0x7f8861e7c0a8>
        unsigned DI file test.c line 126 col 19 size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 context <function_decl 0x7f8861a01d00 child> arg-type <pointer_type 0x7f8861e7c0a8>>
    struct-function 0x7f8861a184d0>

======================================================================
 <integer_cst 0x7f8861a03e40 type <pointer_type 0x7f8861e7c0a8> constant 10>
 <integer_cst 0x7f8861a03e40 type <pointer_type 0x7f8861e7c0a8> constant 10>
this other function ------foo-----

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m
test.c:167:2: warning: use location
  boo(data);
  ^

======================================================================
[40;33m =======POP node_fun stack:child========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m
 <function_decl 0x7f8861a01b00 main
    type <function_type 0x7f8861a007e0
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality>
    nothrow public static function-specific-target function-specific-opt QI file test.c line 266 col 5 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> initial <block 0x7f8861a108a0>
    result <result_decl 0x7f8861e6c618 D.4077 type <integer_type 0x7f8861e755e8 int>
        ignored SI file test.c line 266 col 5 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a01b00 main>>
    struct-function 0x7f8861a18630>

======================================================================
 <ssa_name 0x7f8861a2adc8
    type <integer_type 0x7f8861e757e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f8861e75738 precision 64 min <integer_cst 0x7f8861e61eb8 0> max <integer_cst 0x7f8861e63500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f8861e819d8>>
   
    def_stmt _3 = t;
    version 3>
this other function ------ -----
 
 Start is Pthread Job Collect  

======================================================================
pthread_create (&t, &attr2, child2, _2);
test.c:299:2: warning: use location
  pthread_create(&t, &attr2, child2, (void *)input2);
  ^
this stmt is child function---pthread_create-----

 ================== find ================== 
pthread_create (&t, &attr2, child2, _2);
test.c:299:2: warning: use location
[40;32m    FIND PTHREAD_CREATED STMT  [0m
[40;44m =======trace_function_path main  function_call count: 2 level :-1========  [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun2 argument:main========= [0m
[40;36m ======= relate gimple_assig2n_lhs:í========= [0m
_1 = (long int) input2_25(D);
test.c:299:2: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun2 argument:main========= [0m
[40;36m ======= relate gimple_assig2n_lhs:í========= [0m
_2 = (void *) _1;
test.c:299:2: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:main========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;44m =======print_function_path main  function_call count: 2 level :-1========  [0m
[40;44m =======trace_function_path child2  function_call count: 1 level :0========  [0m
[40;44m =======print_function_path child2  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:child3========= [0m
[40;46m =======add node_fun stack:child3========= [0m
[40;44m =======trace_function_path child3  function_call count: 0 level :1========  [0m
[40;44m =======print_function_path child3  function_call count: 0 level :2========  [0m
[40;44m =======trace_function_path child2  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_8(D)>
_2 = MEM[(int *)_1];
In function ‚Äòchild2‚Äô:
test.c:220:5: warning: use location
  ++(*(int *)data);
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_3 = _2 + 1;
test.c:220:2: warning: use location
  ++(*(int *)data);
  ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_9 = VDEF <.MEM_8(D)>
MEM[(int *)_1] = _3;
test.c:220:2: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_9>
_4 = MEM[(int *)&data];
test.c:221:5: warning: use location
  ++(*(int *)pData);
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_5 = _4 + 1;
test.c:221:2: warning: use location
  ++(*(int *)pData);
  ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_10 = VDEF <.MEM_9>
MEM[(int *)&data] = _5;
test.c:221:2: warning: use location
  ++(*(int *)pData);
  ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= node_fun:child2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;44m =======print_function_path child2  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:child3========= [0m
[40;46m =======add node_fun stack:child3========= [0m
[40;44m =======trace_function_path child3  function_call count: 0 level :1========  [0m
[40;36m ======= node_fun:child3========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;44m =======print_function_path child3  function_call count: 0 level :2========  [0m
[40;32m    FIND PTHREAD_CREATED TYPE is CREATE_JOINABLE  [0m

 ================== find ================== 
pthread_join (_3, 0B);
In function ‚Äòmain‚Äô:
test.c:301:2: warning: use location
  pthread_join(t, NULL);
  ^
this stmt is child function---pthread_join-----

 ================== Start Use after free Check ================== 

======================================================================
[40;32m    pthread is JOINABLE and no memory leak   [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
 <function_decl 0x7f8861a01b00 main
    type <function_type 0x7f8861a007e0
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality>
    nothrow public static function-specific-target function-specific-opt QI file test.c line 266 col 5 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> initial <block 0x7f8861a108a0>
    result <result_decl 0x7f8861e6c618 D.4077 type <integer_type 0x7f8861e755e8 int>
        ignored SI file test.c line 266 col 5 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a01b00 main>>
    struct-function 0x7f8861a18630>

======================================================================
 <ssa_name 0x7f8861a2ae10
    type <pointer_type 0x7f8861a092a0
        type <integer_type 0x7f8861a002a0 pthread_t unsigned DI
            size <integer_cst 0x7f8861e61be8 constant 64>
            unit size <integer_cst 0x7f8861e61c00 constant 8>
            align 64 symtab 0 alias set -1 canonical type 0x7f8861e75738 precision 64 min <integer_cst 0x7f8861e61eb8 0> max <integer_cst 0x7f8861e63500 18446744073709551615> context <translation_unit_decl 0x7f8861e6c168 test.c>
            pointer_to_this <pointer_type 0x7f8861a092a0>>
        unsigned DI size <integer_cst 0x7f8861e61be8 64> unit size <integer_cst 0x7f8861e61c00 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    def_stmt _4 = &t2[i_10];
    version 4
    ptr-info 0x7f8861a35288>
this other function ------pthread_join-----
 
 Start is Pthread Job Collect  

======================================================================
_5 = t2[i_10];
test.c:308:3: warning: use location
   printf("%ld\n", t2[i]);
   ^
_14 = __printf_chk (1, "%ld\n", _5);
this stmt is child function---__printf_chk-----

 ================== trace ================== 
trace fucntion name:__printf_chk 

 ================== trace ================== 
_6 = t2[i_11];
test.c:323:3: warning: use location
   pthread_join(t2[i], NULL);
   ^
pthread_join (_6, 0B);
test.c:323:3: warning: use location
this stmt is child function---pthread_join-----
err_47 = pthread_create (_4, &attr, child, 0B);
test.c:306:7: warning: use location
   int err = pthread_create(&t2[i], &attr, child, NULL);
       ^
this stmt is child function---pthread_create-----

 ================== find ================== 
err_47 = pthread_create (_4, &attr, child, 0B);
test.c:306:7: warning: use location
[40;32m    FIND PTHREAD_CREATED STMT  [0m
[40;44m =======trace_function_path child  function_call count: 2 level :0========  [0m
[40;31m  find pthread_detched stmt  [0m
# .MEM_19 = VDEF <.MEM_18(D)>
pthread_detach (_1);
test.c:129:2: warning: use location
  pthread_detach(pthread_self());
  ^
[40;44m =======print_function_path child  function_call count: 2 level :1========  [0m
[40;42m =======pre add _ fucntion:boo========= [0m
[40;46m =======add node_fun stack:boo========= [0m
[40;44m =======trace_function_path boo  function_call count: 1 level :1========  [0m
[40;44m =======print_function_path boo  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;46m =======add node_fun stack:test22========= [0m
[40;44m =======trace_function_path test22  function_call count: 1 level :2========  [0m
[40;44m =======print_function_path test22  function_call count: 1 level :3========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;41m =======recursive_fun:test22========= [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;46m =======add node_fun stack:foo========= [0m
[40;44m =======trace_function_path foo  function_call count: 1 level :1========  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:foo2========= [0m
[40;46m =======add node_fun stack:foo2========= [0m
[40;44m =======trace_function_path foo2  function_call count: 1 level :2========  [0m
[40;44m =======print_function_path foo2  function_call count: 1 level :3========  [0m
[40;42m =======pre add _ fucntion:foo3========= [0m
[40;46m =======add node_fun stack:foo3========= [0m
[40;44m =======trace_function_path foo3  function_call count: 0 level :3========  [0m
[40;44m =======print_function_path foo3  function_call count: 0 level :4========  [0m
[40;44m =======trace_function_path child  function_call count: 2 level :0========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_32 = VDEF <.MEM_31>
free (_7);
test.c:165:2: warning: use location
  free(pData);
  ^
[40;31m  find pthread_detched stmt  [0m
# .MEM_19 = VDEF <.MEM_18(D)>
pthread_detach (_1);
test.c:129:2: warning: use location
  pthread_detach(pthread_self());
  ^
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_24 = VDEF <.MEM_23>
pData = _2;
In function ‚Äòchild‚Äô:
test.c:155:7: warning: use location
  int *pData = malloc(20);
       ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_26 = VDEF <.MEM_25>
data2 = 0;
test.c:157:6: warning: use location
  int data2 = 0;
      ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_27 = VDEF <.MEM_26>
pData = &data2;
test.c:160:8: warning: use location
  pData = &data2;
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_27>
_3 = pData;
test.c:161:9: warning: use location
  *ppData[0] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_28 = VDEF <.MEM_27>
*_3 = 10;
test.c:161:13: warning: use location
  *ppData[0] = 10;
             ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_28>
_4 = MEM[(int * *)&pData + 8B];
test.c:162:9: warning: use location
  *ppData[1] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_29 = VDEF <.MEM_28>
*_4 = 10;
test.c:162:13: warning: use location
  *ppData[1] = 10;
             ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_29>
_5 = MEM[(int * *)&pData + 16B];
test.c:163:9: warning: use location
  *ppData[2] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_30 = VDEF <.MEM_29>
*_5 = 10;
test.c:163:13: warning: use location
  *ppData[2] = 10;
             ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_30>
_6 = pData;
test.c:164:3: warning: use location
  **ppData = 12;
   ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_31 = VDEF <.MEM_30>
*_6 = 12;
test.c:164:11: warning: use location
  **ppData = 12;
           ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_31>
_7 = pData;
test.c:165:2: warning: use location
  free(pData);
  ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path child  function_call count: 2 level :1========  [0m
[40;42m =======pre add _ fucntion:boo========= [0m
[40;46m =======add node_fun stack:boo========= [0m
[40;44m =======trace_function_path boo  function_call count: 1 level :1========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_8 = VDEF <.MEM_7(D)>
free (b_2(D));
In function ‚Äòmain‚Äô:
test.c:238:2: warning: use location
  free(b);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_9 = VDEF <.MEM_8>
free (b_2(D));
test.c:239:2: warning: use location
  free(b);
  ^
fucntion collect path finsh
[40;44m =======print_function_path boo  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;46m =======add node_fun stack:test22========= [0m
[40;44m =======trace_function_path test22  function_call count: 1 level :2========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_19 = VDEF <.MEM_18>
free (w_10);
test.c:260:2: warning: use location
  free(w);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :3========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;41m =======recursive_fun:test22========= [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;46m =======add node_fun stack:foo========= [0m
[40;44m =======trace_function_path foo  function_call count: 1 level :1========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_10 = VDEF <.MEM_9>
*p2_3 = 1;
In function ‚Äòfoo‚Äô:
test.c:109:8: warning: use location
  p2[0] = 1;
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:foo2========= [0m
[40;46m =======add node_fun stack:foo2========= [0m
[40;44m =======trace_function_path foo2  function_call count: 1 level :2========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (p3_14);
In function ‚Äòmain‚Äô:
test.c:72:3: warning: use location
   free(p3);
   ^
[40;31m  find free stmt free same pointer [0m
# .MEM_46 = VDEF <.MEM_45>
free (p4_16);
test.c:78:3: warning: use location
   free(p4);
   ^
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_1 = (long unsigned int) z_9(D);
In function ‚Äòfoo2‚Äô:
test.c:56:12: warning: use location
  int *a2 = malloc(z);
            ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_2 = (long unsigned int) z_9(D);
test.c:57:12: warning: use location
  int *p3 = malloc(z);
            ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_3 = (long unsigned int) z_9(D);
test.c:58:12: warning: use location
  int *p4 = malloc(z);
            ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_4 = (long unsigned int) z_9(D);
test.c:59:8: warning: use location
  p99 = malloc(z);
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_38 = VDEF <.MEM_37>
p99 = _5;
test.c:59:6: warning: use location
  p99 = malloc(z);
      ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_39 = VDEF <.MEM_38>
*a2_12 = 10;
test.c:61:8: warning: use location
  a2[0] = 10;
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_39>
_6 = p99;
test.c:62:5: warning: use location
  p99[0] = 10;
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_40 = VDEF <.MEM_39>
*_6 = 10;
test.c:62:9: warning: use location
  p99[0] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_47 = VDEF <.MEM_44>
*p3_14 = 10;
test.c:71:9: warning: use location
   p3[0] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_31 = p3_14;
test.c:73:10: warning: use location
   return p3;
          ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_45 = VDEF <.MEM_44>
*p4_16 = 10;
test.c:77:9: warning: use location
   p4[0] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_28 = p4_16;
test.c:79:10: warning: use location
   return p4;
          ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo2  function_call count: 1 level :3========  [0m
[40;42m =======pre add _ fucntion:foo3========= [0m
[40;46m =======add node_fun stack:foo3========= [0m
[40;44m =======trace_function_path foo3  function_call count: 0 level :3========  [0m
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_2 = (long int) _1;
In function ‚Äòfoo3‚Äô:
test.c:51:5: warning: use location
  *z = malloc(1);
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_3 = (int) _2;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_9 = VDEF <.MEM_8>
*z_6(D) = _3;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo3  function_call count: 0 level :4========  [0m
[40;32m    FIND PTHREAD_CREATED TYPE is CREATE_DETACHED  [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;31m  	possible double free :13 [0m

======================================================================
 <function_decl 0x7f8861a01b00 main
    type <function_type 0x7f8861a007e0
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality>
    nothrow public static function-specific-target function-specific-opt QI file test.c line 266 col 5 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> initial <block 0x7f8861a108a0>
    result <result_decl 0x7f8861e6c618 D.4077 type <integer_type 0x7f8861e755e8 int>
        ignored SI file test.c line 266 col 5 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a01b00 main>>
    struct-function 0x7f8861a18630>

======================================================================
 <ssa_name 0x7f8861a31090
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a2d120 q>
    def_stmt q_29 = malloc (5);
    version 29
    ptr-info 0x7f8861a352b8>
q_29 = malloc (5);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
child (q_29);
In function ‚Äòmain‚Äô:
test.c:314:3: warning: use location
   child(q);
   ^
this stmt is child function---child-----

 ================== trace ================== 
trace fucntion name:child 
[40;44m =======trace_function_path child  function_call count: 2 level :0========  [0m
[40;31m  find pthread_detched stmt  [0m
# .MEM_19 = VDEF <.MEM_18(D)>
pthread_detach (_1);
test.c:129:2: warning: use location
  pthread_detach(pthread_self());
  ^
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_24 = VDEF <.MEM_23>
pData = _2;
In function ‚Äòchild‚Äô:
test.c:155:7: warning: use location
  int *pData = malloc(20);
       ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_26 = VDEF <.MEM_25>
data2 = 0;
test.c:157:6: warning: use location
  int data2 = 0;
      ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_27 = VDEF <.MEM_26>
pData = &data2;
test.c:160:8: warning: use location
  pData = &data2;
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_28 = VDEF <.MEM_27>
*_3 = 10;
test.c:161:13: warning: use location
  *ppData[0] = 10;
             ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_29 = VDEF <.MEM_28>
*_4 = 10;
test.c:162:13: warning: use location
  *ppData[1] = 10;
             ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_30 = VDEF <.MEM_29>
*_5 = 10;
test.c:163:13: warning: use location
  *ppData[2] = 10;
             ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:data========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_31 = VDEF <.MEM_30>
*_6 = 12;
test.c:164:11: warning: use location
  **ppData = 12;
           ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:child========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
fucntion collect path finsh
[40;44m =======print_function_path child  function_call count: 2 level :1========  [0m
[40;42m =======pre add _ fucntion:boo========= [0m
[40;46m =======add node_fun stack:boo========= [0m
[40;44m =======trace_function_path boo  function_call count: 1 level :1========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_8 = VDEF <.MEM_7(D)>
free (b_2(D));
In function ‚Äòmain‚Äô:
test.c:238:2: warning: use location
  free(b);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_9 = VDEF <.MEM_8>
free (b_2(D));
test.c:239:2: warning: use location
  free(b);
  ^
fucntion collect path finsh
[40;44m =======print_function_path boo  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;46m =======add node_fun stack:test22========= [0m
[40;44m =======trace_function_path test22  function_call count: 1 level :2========  [0m
[40;31m  find free stmt free same pointer [0m
# .MEM_12 = VDEF <.MEM_11(D)>
free (k_2(D));
test.c:253:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_13 = VDEF <.MEM_12>
free (k_2(D));
test.c:254:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_14 = VDEF <.MEM_13>
free (k_2(D));
test.c:255:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (k_2(D));
test.c:256:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_16 = VDEF <.MEM_15>
free (k_2(D));
test.c:257:2: warning: use location
  free(k);
  ^
[40;31m  find free stmt free same pointer [0m
# .MEM_17 = VDEF <.MEM_16>
free (k_2(D));
test.c:258:2: warning: use location
  free(k);
  ^
fucntion collect path finsh
[40;44m =======print_function_path test22  function_call count: 1 level :3========  [0m
[40;42m =======pre add _ fucntion:test22========= [0m
[40;41m =======recursive_fun:test22========= [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;46m =======add node_fun stack:foo========= [0m
[40;44m =======trace_function_path foo  function_call count: 1 level :1========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_10 = VDEF <.MEM_9>
*p2_3 = 1;
In function ‚Äòfoo‚Äô:
test.c:109:8: warning: use location
  p2[0] = 1;
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo  function_call count: 1 level :2========  [0m
[40;42m =======pre add _ fucntion:foo2========= [0m
[40;46m =======add node_fun stack:foo2========= [0m
[40;44m =======trace_function_path foo2  function_call count: 1 level :2========  [0m
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_1 = (long unsigned int) z_9(D);
In function ‚Äòfoo2‚Äô:
test.c:56:12: warning: use location
  int *a2 = malloc(z);
            ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_2 = (long unsigned int) z_9(D);
test.c:57:12: warning: use location
  int *p3 = malloc(z);
            ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_3 = (long unsigned int) z_9(D);
test.c:58:12: warning: use location
  int *p4 = malloc(z);
            ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_4 = (long unsigned int) z_9(D);
test.c:59:8: warning: use location
  p99 = malloc(z);
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:#========= [0m
# .MEM_38 = VDEF <.MEM_37>
p99 = _5;
test.c:59:6: warning: use location
  p99 = malloc(z);
      ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_39 = VDEF <.MEM_38>
*a2_12 = 10;
test.c:61:8: warning: use location
  a2[0] = 10;
        ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_39>
_6 = p99;
test.c:62:5: warning: use location
  p99[0] = 10;
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_40 = VDEF <.MEM_39>
*_6 = 10;
test.c:62:9: warning: use location
  p99[0] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_47 = VDEF <.MEM_44>
*p3_14 = 10;
test.c:71:9: warning: use location
   p3[0] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_45 = VDEF <.MEM_44>
*p4_16 = 10;
test.c:77:9: warning: use location
   p4[0] = 10;
         ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
fucntion collect path finsh
[40;44m =======print_function_path foo2  function_call count: 1 level :3========  [0m
[40;42m =======pre add _ fucntion:foo3========= [0m
[40;46m =======add node_fun stack:foo3========= [0m
[40;44m =======trace_function_path foo3  function_call count: 0 level :3========  [0m
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_2 = (long int) _1;
In function ‚Äòfoo3‚Äô:
test.c:51:5: warning: use location
  *z = malloc(1);
     ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
_3 = (int) _2;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo3========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:û========= [0m
# .MEM_9 = VDEF <.MEM_8>
*z_6(D) = _3;
test.c:51:5: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo3  function_call count: 0 level :4========  [0m

 ================== trace ================== 
_9 = foo5 (q_29, q_29);
In function ‚Äòmain‚Äô:
test.c:343:2: warning: use location
  printf("fuck%d\n", foo5(q, q));
  ^
this stmt is child function---foo5-----

 ================== trace ================== 
trace fucntion name:foo5 
[40;44m =======trace_function_path foo5  function_call count: 0 level :0========  [0m
[40;36m ======= node_fun:foo5========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_9(D)>
_1 = *z_4(D);
In function ‚Äòfoo5‚Äô:
test.c:36:2: warning: use location
  printf("fuck%d\n", *z);
  ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= relate node_fun argument:y========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_9(D)>
_1 = *z_4(D);
test.c:36:2: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= node_fun:foo5========= [0m
[40;36m ======= find relate stmt with q ========= [0m
[40;36m ======= relate stmt argument:q ========= [0m
[40;36m ======= relate node_fun argument:z========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_10>
_2 = *y_5(D);
test.c:37:2: warning: use location
  printf("fuck%d\n", *y);
  ^

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
[40;36m ======= relate node_fun argument:y========= [0m
[40;36m ======= relate gimple_assign_lhs:í========= [0m
# VUSE <.MEM_10>
_2 = *y_5(D);
test.c:37:2: warning: use location

 ================== warring ================== 
[40;35m this pointer possible  reference other address [0m
[40;35m or assign other value [0m

 ================== warring ================== 
fucntion collect path finsh
[40;44m =======print_function_path foo5  function_call count: 0 level :1========  [0m

 ================== trace ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;31m  	possible double free :9 [0m

======================================================================
 <function_decl 0x7f8861a01b00 main
    type <function_type 0x7f8861a007e0
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality>
    nothrow public static function-specific-target function-specific-opt QI file test.c line 266 col 5 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> initial <block 0x7f8861a108a0>
    result <result_decl 0x7f8861e6c618 D.4077 type <integer_type 0x7f8861e755e8 int>
        ignored SI file test.c line 266 col 5 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a01b00 main>>
    struct-function 0x7f8861a18630>

======================================================================
 <ssa_name 0x7f8861a31120
    type <pointer_type 0x7f8861e7ca80
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        public unsigned DI
        size <integer_cst 0x7f8861e61be8 constant 64>
        unit size <integer_cst 0x7f8861e61c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f8861a0ce70>>
    var <var_decl 0x7f8861a2d090 data>
    def_stmt data_33 = malloc (400);
    version 33
    ptr-info 0x7f8861a352d0>
data_33 = malloc (400);
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
data_12 = PHI <0B(10), data_33(13)>
In function ‚Äòmain‚Äô:
lto1: warning: use location
this stmt have mutiple branch ---malloc-----
free (data_12);
test.c:341:3: warning: use location
   free(data);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (data_12);
test.c:341:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
free (data_33);
test.c:336:3: warning: use location
   free(data);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (data_33);
test.c:336:3: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;31m  	possible double free :2 [0m

======================================================================
 <function_decl 0x7f8861a01b00 main
    type <function_type 0x7f8861a007e0
        type <integer_type 0x7f8861e755e8 int public SI
            size <integer_cst 0x7f8861e61e28 constant 32>
            unit size <integer_cst 0x7f8861e61e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
            pointer_to_this <pointer_type 0x7f8861e7ca80>>
        QI
        size <integer_cst 0x7f8861e61cd8 constant 8>
        unit size <integer_cst 0x7f8861e61cf0 constant 1>
        align 8 symtab 0 alias set -1 structural equality>
    nothrow public static function-specific-target function-specific-opt QI file test.c line 266 col 5 align 8 context <translation_unit_decl 0x7f8861e6c168 test.c> initial <block 0x7f8861a108a0>
    result <result_decl 0x7f8861e6c618 D.4077 type <integer_type 0x7f8861e755e8 int>
        ignored SI file test.c line 266 col 5 size <integer_cst 0x7f8861e61e28 32> unit size <integer_cst 0x7f8861e61e40 4>
        align 32 context <function_decl 0x7f8861a01b00 main>>
    struct-function 0x7f8861a18630>

======================================================================
 <ssa_name 0x7f8861a2af78
    type <integer_type 0x7f8861e755e8 int public SI
        size <integer_cst 0x7f8861e61e28 constant 32>
        unit size <integer_cst 0x7f8861e61e40 constant 4>
        align 32 symtab 0 alias set -1 canonical type 0x7f8861e755e8 precision 32 min <integer_cst 0x7f8861e61de0 -2147483648> max <integer_cst 0x7f8861e61df8 2147483647>
        pointer_to_this <pointer_type 0x7f8861e7ca80>>
   
    def_stmt _9 = foo5 (q_29, q_29);
    version 9>
this other function ------foo5-----
 
 Start check Pointer Collect  

======================================================================
_39 = __printf_chk (1, "fuck%d\n", _9);
this stmt is child function---__printf_chk-----

 ================== trace ================== 
trace fucntion name:__printf_chk 

 ================== trace ================== 

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
fucntion collect path finsh
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    find Entry point : 18
 [0m
[40;34m    used_stmt array stack totalsize of : 408
 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
=======Mapping node_fun:foo5=========
<bb 2> [100.00%]:
_1 = *z_4(D);
_8 = __printf_chk (1, "fuck%d\n", _1);
_2 = *y_5(D);
_7 = __printf_chk (1, "fuck%d\n", _2);
_6 = __printf_chk (1, "fuck%d\n", 10);
return 10;

=======is loop:0=========
=======Mapping node_fun:foo3=========
<bb 2> [100.00%]:
_1 = malloc (1);
_2 = (long int) _1;
_3 = (int) _2;
*z_6(D) = _3;
return;

=======is loop:0=========
=======Mapping node_fun:foo2=========
<bb 2> [100.00%]:
_1 = (long unsigned int) z_9(D);
a2_12 = malloc (_1);
_2 = (long unsigned int) z_9(D);
p3_14 = malloc (_2);
_3 = (long unsigned int) z_9(D);
p4_16 = malloc (_3);
_4 = (long unsigned int) z_9(D);
_5 = malloc (_4);
p99 = _5;
*a2_12 = 10;
_6 = p99;
*_6 = 10;
pthread_mutex_lock (&mLock);
pthread_mutex_lock (&mLock2);
pthread_mutex_lock (&mLock3);
foo3 (p3_14);
if (tmp_25(D) > 10)
  goto <bb 3>; [46.00%]
else
  goto <bb 4>; [54.00%]

=======is loop:0=========
<bb 3> [46.00%]:
*p3_14 = 10;
free (p3_14);
_31 = p3_14;
goto <bb 5>; [100.00%]

=======is loop:0=========
<bb 4> [54.00%]:
*p4_16 = 10;
free (p4_16);
_28 = p4_16;

=======is loop:0=========
<bb 5> [100.00%]:
# _7 = PHI <p3_14(3), p4_16(4)>
return _7;

=======is loop:0=========
=======Mapping node_fun:foo=========
<bb 2> [100.00%]:
p2_3 = malloc (1);
*p2_3 = 1;
_7 = foo2 (z_5(D));
return _7;

=======is loop:0=========
=======Mapping node_fun:child3=========
<bb 2> [100.00%]:
_1 = data;
free (_1);
_5 = __printf_chk (1, "asdda%d\n", &MEM[(void *)&data + 4B]);
_4 = __printf_chk (1, "asdda%d\n", 10);
return;

=======is loop:0=========
=======Mapping node_fun:boo=========
<bb 2> [100.00%]:
free (b_2(D));
free (b_2(D));
test22 (b_2(D));
_6 = __printf_chk (1, "asdda\n");
return;

=======is loop:0=========
=======Mapping node_fun:test22=========
<bb 2> [100.00%]:
free (k_2(D));
free (k_2(D));
free (k_2(D));
free (k_2(D));
free (k_2(D));
free (k_2(D));
w_10 = malloc (5);
free (w_10);
test22 (k_2(D));
return;

=======is loop:0=========
=======Mapping node_fun:child=========
<bb 2> [100.00%]:
_1 = pthread_self ();
pthread_detach (_1);
pthread_mutex_lock (&mLock);
pthread_mutex_lock (&mLock);
ppData_13 = malloc (10);
_2 = malloc (20);
pData = _2;
a_17 = foo (1);
data2 = 0;
pData = &data2;
_3 = pData;
*_3 = 10;
_4 = MEM[(int * *)&pData + 8B];
*_4 = 10;
_5 = MEM[(int * *)&pData + 16B];
*_5 = 10;
_6 = pData;
*_6 = 12;
_7 = pData;
free (_7);
free (10B);
boo (10B);
free (&pData);
pthread_mutex_unlock (&mLock);
free (&pData);
pthread_exit (0B);

=======is loop:0=========
=======Mapping node_fun:child2=========
<bb 2> [100.00%]:
_1 = data;
_2 = MEM[(int *)_1];
_3 = _2 + 1;
MEM[(int *)_1] = _3;
_4 = MEM[(int *)&data];
_5 = _4 + 1;
MEM[(int *)&data] = _5;
_6 = data;
child3 (_6);
_7 = data;
free (_7);
return;

=======is loop:0=========
=======Mapping node_fun:main=========
<bb 2> [25.00%]:
input[0] = 1;
input[1] = 2;
pthread_attr_init (&attr);
pthread_attr_init (&attr2);
pthread_attr_setdetachstate (&attr, 1);
pthread_attr_setdetachstate (&attr2, 0);
_1 = (long int) input2_25(D);
_2 = (void *) _1;
pthread_create (&t, &attr2, child2, _2);
_3 = t;
pthread_join (_3, 0B);
goto <bb 4>; [100.00%]

=======is loop:0=========
<bb 3> [75.00%]:
_4 = &t2[i_10];
err_47 = pthread_create (_4, &attr, child, 0B);
_5 = t2[i_10];
_14 = __printf_chk (1, "%ld\n", _5);
i_48 = i_10 + 1;

=======is loop:1=========
<bb 4> [100.00%]:
# i_10 = PHI <0(2), i_48(3)>
if (i_10 <= 2)
  goto <bb 3>; [75.00%]
else
  goto <bb 5>; [25.00%]

=======is loop:1=========
<bb 5> [25.00%]:
q_29 = malloc (5);
if (q_29 != 0B)
  goto <bb 6>; [0.04%]
else
  goto <bb 7>; [99.96%]

=======is loop:0=========
<bb 6> [0.01%]:
child (q_29);

=======is loop:0=========
<bb 7> [24.99%]:
_31 = __printf_chk (1, "fuck\n");
goto <bb 9>; [100.00%]

=======is loop:0=========
<bb 8> [74.97%]:
_6 = t2[i_11];
pthread_join (_6, 0B);
i_45 = i_11 + 1;

=======is loop:1=========
<bb 9> [99.96%]:
# i_11 = PHI <0(7), i_45(8)>
if (i_11 <= 2)
  goto <bb 8>; [75.00%]
else
  goto <bb 10>; [25.00%]

=======is loop:1=========
<bb 10> [24.99%]:
_7 = staticTrue;
if (_7 != 0)
  goto <bb 11>; [33.00%]
else
  goto <bb 14>; [67.00%]

=======is loop:0=========
<bb 11> [8.25%]:
data_33 = malloc (400);
if (data_33 == 0B)
  goto <bb 12>; [0.04%]
else
  goto <bb 13>; [99.96%]

=======is loop:0=========
<bb 12> [0.00%]:
exit (-1);

=======is loop:0=========
<bb 13> [8.24%]:
free (data_33);

=======is loop:0=========
<bb 14> [24.99%]:
# data_12 = PHI <0B(10), data_33(13)>
_8 = staticTrue;
if (_8 != 0)
  goto <bb 15>; [36.64%]
else
  goto <bb 16>; [63.36%]

=======is loop:0=========
<bb 15> [9.16%]:
free (data_12);

=======is loop:0=========
<bb 16> [24.99%]:
_9 = foo5 (q_29, q_29);
_39 = __printf_chk (1, "fuck%d\n", _9);
input ={v} {CLOBBER};
attr ={v} {CLOBBER};
attr2 ={v} {CLOBBER};
t ={v} {CLOBBER};
t2 ={v} {CLOBBER};
return 0;

=======is loop:0=========
time: 0.041523 s
test.c: In function ‚Äòchild‚Äô:
test.c:165:2: warning: attempt to free a non-heap object ‚Äòdata2‚Äô [-Wfree-nonheap-object]
  free(pData);
  ^
test.c:168:2: warning: attempt to free a non-heap object ‚ÄòpData‚Äô [-Wfree-nonheap-object]
  free(ppData);
  ^
test.c:170:2: warning: attempt to free a non-heap object ‚ÄòpData‚Äô [-Wfree-nonheap-object]
  free(ppData);
  ^
